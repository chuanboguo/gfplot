# Comparison of INLA with glmmfields for `INLA::SPDEtoy` example

Let's run the SPDEtoy example from the INLA book:

```{r, results='hide', message=FALSE, warning=FALSE}
library(INLA)
library(tidyverse)
```

```{r}
data(SPDEtoy)
coords <- as.matrix(SPDEtoy[,1:2])
bnd <- inla.nonconvex.hull(as.matrix(coords),convex=0.07)
mesh6 <- inla.mesh.2d(loc=coords, boundary=bnd, max.edge=c(0.04, 0.2), cutoff=0.05, offset = c(0.1, 0.4))
plot(mesh6)
# The R-INLA function inla.spde.make.A creates the sparse weight matrix A by identifying the data locations in the mesh and organizing the corresponding values of the basis functions. 
A.est6 <- inla.spde.make.A(mesh=mesh6, loc=coords)
spde <- inla.spde2.matern(mesh=mesh6, alpha=1.5)
# Then we define the linear predictor through the formula
formula <- y ~ -1 + intercept + f(spatial.field, model=spde)
# removing the default intercept (with the code spefication -1) and including an explicit one named intercept. The spatial random effect is included with the f() term where spatial.field is a proper index variable and spde is the model created previously with inla.spde2.matern. As usual the model is fitted by means of the inla function:
# We also introduce a new function named inla.spde.make.index which takes care of creating all the required indexes for the SPDE model
s.index <- inla.spde.make.index(name="spatial.field", n.spde=spde$n.spde)
# Here name represents the name of the effect which will then be used in the formula. The output returned by inla.spde.make.index is composed of a list with the following components:
stack.est <- inla.stack(data=list(y=SPDEtoy$y), A=list(A.est6), 
  effects=list(c(s.index, list(intercept=1))), tag="est") #Estimation
output6.stack <- inla(formula, data=inla.stack.data(stack.est, spde=spde), 
  family="gaussian", control.predictor=list(A=inla.stack.A(stack.est), compute=TRUE))
grid.x <- 50
grid.y <- 50
pred.grid <- expand.grid(x = seq(0, 1, length.out = grid.x), y = seq(0, 1, length.out = grid.y))
# In R-INLA, the simplest way for performing spatial prediction is by joining linear predictors (one for parameter estimation and one for prediction) through the inla.stack function, as described in the previous section. To do this, first of all a new projector matrix for the 2500 grid locations has to be created:
A.pred6 <- inla.spde.make.A(mesh=mesh6, loc=as.matrix(pred.grid))
# and then the inla.stack object is built using a proper tag (pred.latent):
stack.pred.latent <- inla.stack(data=list(xi=NA), A=list(A.pred6), 
  effects=list(s.index), tag="pred.latent")
stack.pred.response <- inla.stack(data=list(y=NA), A=list(A.pred6), 
  effects=list(c(s.index, list(intercept=1))), tag="pred.response")
# We join all together the three linear predictors (parameter estimation, prediction of the latent field and prediction of the response) into a single joint stack object:
join.stack <- inla.stack(stack.est, stack.pred.latent, stack.pred.response)
# and call the inla function
join.output <- inla(formula, data=inla.stack.data(join.stack), control.predictor=list(A=inla.stack.A(join.stack), compute=TRUE))
# To access the posterior marginal distributions of predictions at the target grid locations, we use the inla.stack.index function to extract the corresponding data indexes from the full stack object using the corresponding tags:
index.pred.response <- inla.stack.index(join.stack, tag="pred.response")$data
post.mean.pred.response <- join.output$summary.linear.predictor[index.pred.response,"mean"]
# post.mean.pred.response.sd <- join.output$summary.linear.predictor[index.pred.response,"sd"]

pred.grid$z <- post.mean.pred.response
# pred.grid2 <- pred.grid %>% rename(s1 = x, s2 = y) %>% mutate(time = 1)

ggplot(pred.grid, aes(x, y)) + geom_tile(aes(fill = z)) + 
  geom_point(data = SPDEtoy, aes(x = s1, y = s2, size = y), pch = 21) +
  viridis::scale_fill_viridis(limits = c(4, 14)) +
  ggtitle("R-INLA")
```

## Now with the trawl survey data 

```{r}
d <- readRDS("../../Dropbox/dfo/data/all-survey-catches.rds")
names(d) <- tolower(names(d))
d$species_common_name <- tolower(d$species_common_name)
d$species_science_name <- tolower(d$species_science_name)
d$year <- lubridate::year(d$trip_start_date)

all <- filter(d, survey_series_desc %in%"West Coast Vancouver Island Synoptic Survey") %>% 
    filter(year == 2012) %>% 
  select(year, start_lon, start_lat, fe_bottom_water_temp_depth, trip_id, fishing_event_id, set_num) %>% unique()

sp <- filter(d, species_common_name %in% "pacific ocean perch") %>% 
  filter(!is.na(catch_weight)) %>% 
  filter(year %in% seq(2004, 2012, 2)) %>% 
  filter(survey_series_desc %in%"West Coast Vancouver Island Synoptic Survey") %>% 
  filter(year == 2012)

dat <- sp
# dat <- filter(dat, start_lon > -128, start_lon < 125, start_lat > 48, start_lat < 50.3)
nrow(dat)
# dat <- filter(dat, fe_bottom_water_temperature > 1, fe_bottom_water_temperature < 12,
  # !is.na(fe_bottom_water_temp_depth), !is.na(fe_bottom_water_temperature))
nrow(dat)

dat <- mutate(dat, density = catch_weight / 
    (fe_distance_travelled * mean(d$trlsp_doorspread, na.rm = TRUE)))

dat <- left_join(all, dat)
dat$density[is.na(dat$density)] <- 0
dat$catch_weight[is.na(dat$catch_weight)] <- 0

dat <- select(dat, year, start_lon, start_lat, catch_weight, fe_bottom_water_temp_depth, density) %>%
  rename(X = start_lon, Y = start_lat)

## binomial?
dat <- mutate(dat, present = ifelse(density > 0, 1, 0))
dat <- filter(dat, present == 1)

attr(dat, "projection") <- "LL"
dat <- PBSmapping::convUL(dat)
dat <- as.data.frame(na.omit(dat))

ggplot(dat, aes(X, Y, colour = log(density))) + geom_point()

coords = cbind(dat$X, dat$Y)

bnd = inla.nonconvex.hull(coords, convex = 20)
mesh6 = inla.mesh.2d(
  boundary = bnd,
  max.edge = c(10, 25),
  cutoff = 1,
  offset = 2
)
plot(mesh6)
points(dat$X, dat$Y, col = "red")

A.est6 <- inla.spde.make.A(mesh=mesh6, loc=coords)
spde <- inla.spde2.matern(mesh=mesh6, alpha=1.5)
# Then we define the linear predictor through the formula
formula <- y ~ -1 + intercept + fe_bottom_water_temp_depth + fe_bottom_water_temp_depth_sq + f(spatial.field, model=spde)
# removing the default intercept (with the code spefication -1) and including an explicit one named intercept. The spatial random effect is included with the f() term where spatial.field is a proper index variable and spde is the model created previously with inla.spde2.matern. As usual the model is fitted by means of the inla function:
# We also introduce a new function named inla.spde.make.index which takes care of creating all the required indexes for the SPDE model
s.index <- inla.spde.make.index(name="spatial.field", n.spde=spde$n.spde)
# Here name represents the name of the effect which will then be used in the formula. The output returned by inla.spde.make.index is composed of a list with the following components:
stack.est <- inla.stack(data=list(y=log(dat$density)), A=list(A.est6, 1, 1), 
  effects=
    list(c(s.index, list(intercept=1)), 
      list(fe_bottom_water_temp_depth = scale(dat$fe_bottom_water_temp_depth)),
      list(fe_bottom_water_temp_depth_sq = I(scale(dat$fe_bottom_water_temp_depth)^2)
        )), 
  tag="est") #Estimation
output6.stack <- inla(formula, data=inla.stack.data(stack.est, spde=spde), 
  family="gaussian", control.predictor=list(A=inla.stack.A(stack.est), compute=TRUE), 
  verbose=FALSE)
summary(output6.stack)
```

Prediction:

```{r}
inner_poly <- cbind(loc[t(cbind(segm$idx[idx, , drop = FALSE], NA)), 1], 
  loc[t(cbind(segm$idx[idx, , drop = FALSE], NA)), 2]) %>% na.omit() %>% 
  as.data.frame()
plot(inner_poly)

x <- inner_poly[,1]
y <- inner_poly[,2]
z <- chull(inner_poly[,1],inner_poly[,2])
coords <- cbind(x[z], y[z])
coords <- rbind(coords, coords[1,])
plot(dat$X, dat$Y)
lines(coords, col="red")


segm <- mesh6$segm$int
idx <- unique(as.vector(segm$idx))
loc <- mesh6$loc




library("rgdal")
sp_poly <- SpatialPolygons(list(Polygons(list(Polygon(coords)), ID=1)))
# set coordinate reference system with SpatialPolygons(..., proj4string=CRS(...))
# e.g. CRS("+proj=longlat +datum=WGS84")
sp_poly_df <- SpatialPolygonsDataFrame(sp_poly, data=data.frame(ID=1))

pred_grid <- expand.grid(X = seq(min(dat$X),max(dat$X), length.out = 100), 
  Y = seq(min(dat$Y), max(dat$Y), length.out = 100), year = unique(dat$year))
coordinates(pred_grid) <- c("X", "Y")
inside <- !is.na(over(pred_grid, as(sp_poly_df, "SpatialPolygons")))
pred_grid <- pred_grid[inside, ]
# plot(pred_grid)
pred_grid <- as.data.frame(pred_grid)
plot(pred_grid$X, pred_grid$Y)

pred.grid <- pred_grid
# In R-INLA, the simplest way for performing spatial prediction is by joining linear predictors (one for parameter estimation and one for prediction) through the inla.stack function, as described in the previous section. To do this, first of all a new projector matrix for the 2500 grid locations has to be created:
A.pred6 <- inla.spde.make.A(mesh=mesh6, loc=as.matrix(pred.grid))
# and then the inla.stack object is built using a proper tag (pred.latent):
stack.pred.latent <- inla.stack(data=list(xi=NA), A=list(A.pred6), 
  effects=list(s.index), tag="pred.latent")
stack.pred.response <- inla.stack(data=list(y=NA), A=list(A.pred6), 
  effects=list(c(s.index, list(intercept=1))), tag="pred.response")
# We join all together the three linear predictors (parameter estimation, prediction of the latent field and prediction of the response) into a single joint stack object:
join.stack <- inla.stack(stack.est, stack.pred.latent, stack.pred.response)
# and call the inla function
join.output <- inla(formula, data=inla.stack.data(join.stack), control.predictor=list(A=inla.stack.A(join.stack), compute=TRUE))
# To access the posterior marginal distributions of predictions at the target grid locations, we use the inla.stack.index function to extract the corresponding data indexes from the full stack object using the corresponding tags:
index.pred.response <- inla.stack.index(join.stack, tag="pred.response")$data
post.mean.pred.response <- join.output$summary.linear.predictor[index.pred.response,"mean"]
# post.mean.pred.response.sd <- join.output$summary.linear.predictor[index.pred.response,"sd"]

pred.grid$z <- post.mean.pred.response
# pred.grid2 <- pred.grid %>% rename(s1 = x, s2 = y) %>% mutate(time = 1)

ggplot(pred.grid, aes(X, Y)) + geom_tile(aes(fill = z)) + 
  geom_point(data = dat, aes(x = X, y = Y, size = density), pch = 21) +
  viridis::scale_fill_viridis() +
  ggtitle("R-INLA")
```